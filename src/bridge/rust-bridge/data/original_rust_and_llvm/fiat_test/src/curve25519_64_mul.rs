//! Autogenerated: 'src/ExtractionOCaml/unsaturated_solinas' --lang Rust --inline 25519 64 '(auto)' '2^255 - 19' carry_mul carry_square carry add sub opp selectznz to_bytes from_bytes relax carry_scmul121666
//! curve description: 25519
//! machine_wordsize = 64 (from "64")
//! requested operations: carry_mul, carry_square, carry, add, sub, opp, selectznz, to_bytes, from_bytes, relax, carry_scmul121666
//! n = 5 (from "(auto)")
//! s-c = 2^255 - [(1, 19)] (from "2^255 - 19")
//! tight_bounds_multiplier = 1 (from "")
//!
//! Computed values:
//!   carry_chain = [0, 1, 2, 3, 4, 0, 1]
//!   eval z = z[0] + (z[1] << 51) + (z[2] << 102) + (z[3] << 153) + (z[4] << 204)
//!   bytes_eval z = z[0] + (z[1] << 8) + (z[2] << 16) + (z[3] << 24) + (z[4] << 32) + (z[5] << 40) + (z[6] << 48) + (z[7] << 56) + (z[8] << 64) + (z[9] << 72) + (z[10] << 80) + (z[11] << 88) + (z[12] << 96) + (z[13] << 104) + (z[14] << 112) + (z[15] << 120) + (z[16] << 128) + (z[17] << 136) + (z[18] << 144) + (z[19] << 152) + (z[20] << 160) + (z[21] << 168) + (z[22] << 176) + (z[23] << 184) + (z[24] << 192) + (z[25] << 200) + (z[26] << 208) + (z[27] << 216) + (z[28] << 224) + (z[29] << 232) + (z[30] << 240) + (z[31] << 248)
//!   balance = [0xfffffffffffda, 0xffffffffffffe, 0xffffffffffffe, 0xffffffffffffe, 0xffffffffffffe]

#![allow(unused_parens)]
#![allow(non_camel_case_types)]

/** fiat_25519_u1 represents values of 1 bits, stored in one byte. */
pub type fiat_25519_u1 = u8;
/** fiat_25519_i1 represents values of 1 bits, stored in one byte. */
pub type fiat_25519_i1 = i8;
/** fiat_25519_u2 represents values of 2 bits, stored in one byte. */
pub type fiat_25519_u2 = u8;
/** fiat_25519_i2 represents values of 2 bits, stored in one byte. */
pub type fiat_25519_i2 = i8;

/** The type fiat_25519_loose_field_element is a field element with loose bounds. */
/** Bounds: [[0x0 ~> 0x18000000000000], [0x0 ~> 0x18000000000000], [0x0 ~> 0x18000000000000], [0x0 ~> 0x18000000000000], [0x0 ~> 0x18000000000000]] */
#[derive(Clone, Copy)]
pub struct fiat_25519_loose_field_element(pub [u64; 5]);

impl core::ops::Index<usize> for fiat_25519_loose_field_element {
    type Output = u64;
    #[inline]
    fn index(&self, index: usize) -> &Self::Output {
        &self.0[index]
    }
}

impl core::ops::IndexMut<usize> for fiat_25519_loose_field_element {
    #[inline]
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.0[index]
    }
}

/** The type fiat_25519_tight_field_element is a field element with tight bounds. */
/** Bounds: [[0x0 ~> 0x8000000000000], [0x0 ~> 0x8000000000000], [0x0 ~> 0x8000000000000], [0x0 ~> 0x8000000000000], [0x0 ~> 0x8000000000000]] */
#[derive(Clone, Copy)]
pub struct fiat_25519_tight_field_element(pub [u64; 5]);

impl core::ops::Index<usize> for fiat_25519_tight_field_element {
    type Output = u64;
    #[inline]
    fn index(&self, index: usize) -> &Self::Output {
        &self.0[index]
    }
}

impl core::ops::IndexMut<usize> for fiat_25519_tight_field_element {
    #[inline]
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.0[index]
    }
}

/// The function fiat_25519_carry_mul multiplies two field elements and reduces the result.
///
/// Postconditions:
///   eval out1 mod m = (eval arg1 * eval arg2) mod m
///
#[no_mangle]
#[inline]
pub fn fiat_25519_carry_mul(out1: &mut fiat_25519_tight_field_element, arg1: &fiat_25519_loose_field_element, arg2: &fiat_25519_loose_field_element) {
  let x1: u128 = (((arg1[4]) as u128) * (((arg2[4]) * 0x13) as u128));
  let x2: u128 = (((arg1[4]) as u128) * (((arg2[3]) * 0x13) as u128));
  let x3: u128 = (((arg1[4]) as u128) * (((arg2[2]) * 0x13) as u128));
  let x4: u128 = (((arg1[4]) as u128) * (((arg2[1]) * 0x13) as u128));
  let x5: u128 = (((arg1[3]) as u128) * (((arg2[4]) * 0x13) as u128));
  let x6: u128 = (((arg1[3]) as u128) * (((arg2[3]) * 0x13) as u128));
  let x7: u128 = (((arg1[3]) as u128) * (((arg2[2]) * 0x13) as u128));
  let x8: u128 = (((arg1[2]) as u128) * (((arg2[4]) * 0x13) as u128));
  let x9: u128 = (((arg1[2]) as u128) * (((arg2[3]) * 0x13) as u128));
  let x10: u128 = (((arg1[1]) as u128) * (((arg2[4]) * 0x13) as u128));
  let x11: u128 = (((arg1[4]) as u128) * ((arg2[0]) as u128));
  let x12: u128 = (((arg1[3]) as u128) * ((arg2[1]) as u128));
  let x13: u128 = (((arg1[3]) as u128) * ((arg2[0]) as u128));
  let x14: u128 = (((arg1[2]) as u128) * ((arg2[2]) as u128));
  let x15: u128 = (((arg1[2]) as u128) * ((arg2[1]) as u128));
  let x16: u128 = (((arg1[2]) as u128) * ((arg2[0]) as u128));
  let x17: u128 = (((arg1[1]) as u128) * ((arg2[3]) as u128));
  let x18: u128 = (((arg1[1]) as u128) * ((arg2[2]) as u128));
  let x19: u128 = (((arg1[1]) as u128) * ((arg2[1]) as u128));
  let x20: u128 = (((arg1[1]) as u128) * ((arg2[0]) as u128));
  let x21: u128 = (((arg1[0]) as u128) * ((arg2[4]) as u128));
  let x22: u128 = (((arg1[0]) as u128) * ((arg2[3]) as u128));
  let x23: u128 = (((arg1[0]) as u128) * ((arg2[2]) as u128));
  let x24: u128 = (((arg1[0]) as u128) * ((arg2[1]) as u128));
  let x25: u128 = (((arg1[0]) as u128) * ((arg2[0]) as u128));
  let x26: u128 = (x25 + (x10 + (x9 + (x7 + x4))));
  let x27: u64 = ((x26 >> 51) as u64);
  let x28: u64 = ((x26 & (0x7ffffffffffff as u128)) as u64);
  let x29: u128 = (x21 + (x17 + (x14 + (x12 + x11))));
  let x30: u128 = (x22 + (x18 + (x15 + (x13 + x1))));
  let x31: u128 = (x23 + (x19 + (x16 + (x5 + x2))));
  let x32: u128 = (x24 + (x20 + (x8 + (x6 + x3))));
  let x33: u128 = ((x27 as u128) + x32);
  let x34: u64 = ((x33 >> 51) as u64);
  let x35: u64 = ((x33 & (0x7ffffffffffff as u128)) as u64);
  let x36: u128 = ((x34 as u128) + x31);
  let x37: u64 = ((x36 >> 51) as u64);
  let x38: u64 = ((x36 & (0x7ffffffffffff as u128)) as u64);
  let x39: u128 = ((x37 as u128) + x30);
  let x40: u64 = ((x39 >> 51) as u64);
  let x41: u64 = ((x39 & (0x7ffffffffffff as u128)) as u64);
  let x42: u128 = ((x40 as u128) + x29);
  let x43: u64 = ((x42 >> 51) as u64);
  let x44: u64 = ((x42 & (0x7ffffffffffff as u128)) as u64);
  let x45: u64 = (x43 * 0x13);
  let x46: u64 = (x28 + x45);
  let x47: u64 = (x46 >> 51);
  let x48: u64 = (x46 & 0x7ffffffffffff);
  let x49: u64 = (x47 + x35);
  let x50: fiat_25519_u1 = ((x49 >> 51) as fiat_25519_u1);
  let x51: u64 = (x49 & 0x7ffffffffffff);
  let x52: u64 = ((x50 as u64) + x38);
  out1[0] = x48;
  out1[1] = x51;
  out1[2] = x52;
  out1[3] = x41;
  out1[4] = x44;
}